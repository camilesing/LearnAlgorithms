#查找
##简单符号表实现的成本总结

|数据结构|算法|最坏情况下的成本（N次插入以后）的查找|最坏情况下的成本（N次插入以后）的插入|平均情况下的成本（N次随机插入后）的查找|平均情况下的成本（N次随机插入后）的插入|是否高效地支持有序性相关的操作|
|:--|:--|:--|:--|:--|:--|:--|
|无序链表|顺序查找|N|N|N/2|N|否|
|二分查找|有序数组|lgN|2N|lgN|N|是|
|二叉查找树|二叉树查找|N|N|1.39LgN|1.39LgN|是|
|红黑树|2-3树查找|2lgN|2lgN|1.001lgN|1.001lgN|是|

## 符号表的花式实现
基于之上的基础，我们可以得出一系列更复杂的符号表。比如二叉查找树，就是将二分查找的效率和链表的灵活性结合起来。

|使用的数据结构|实现|优点|缺点|
|:--|:--|:--|:--|
|链表（顺序查找）|SequentialSearchST|适用于小型问题|对于大型符号表很慢|
|有序数组（二分查找）|BinarySearchST|最优的查找效率和空间需求，能够进行有序性相关的操作|插入操作很慢|
|二叉查找树|BST|实现简单，能够进行有序性相关的操作|没有性能上界的保证，链接需要额外的空间|
|平衡二叉查找树|RedBlackBST|最优查找和插入排序，能够进行有序性相关的操作|链接需要额外的空间|
|散列表|SeparateChainHashSTLinearProbingHashST|能够快速地查找和插入常见类型的数据|需要计算每种类型的数据的散列，无法进行有序性相关的操作，链接和空结点需要额外的空间|

###散列表
散列表可以分为两种：
- 基于拉链法的散列表
- 开放地址散列表

####基于拉链法的散列表
一个散列函数能够将键转换为数组索引。散列算法的第二部是**碰撞处理**，也就是处理两个或多个键的散列值相同的情况。一种直接的办法是将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为**拉链法**，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的M（散列表大小），使得所有的链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

####开放地址散列表
其中最简单的实现是线性探测法的散列表。当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能产生三种结果：
1. 命中。该位置的键和被查找的键相同；
2. 未命中。键为空（该位置没有键）；
3. 继续查找。该位置的键和被查找的键不同；

开发第之类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。

#####键簇与性能
线性探测的平均承办取决于元素在插入数组后聚集成的一组连续的条目，也叫做键簇。显然，短小的键簇才能保证较高的效率。随着插入的键越来越多，这个要求会很难满足，较长的键簇会越来越多。

##内存使用：符号表的内存使用
|方法|N个元素所需的内存（引用类型）|
|:--|:--|
|基于拉链法的散列表|~48N+32M|
|基于线性探测表的散列表|在~32N和~128N之间|
|各种二叉查找树|~56N|

拉链法和线性探测法的详细比较取决于实现的细节和用例空间和时间的要求。即使基于性能考虑，选择拉链法而非线性探测法也不一定是合理的。在实践中，两种方法的性能差别主要是因为拉链法为每个键值对都分配了一小块内存而线性探测则为整张表使用了两个很大的数组。对于非常大的散列表，这些做法对内存管理系统的要求也很不相同。在现代系统中，在性能优化的情景下，最好由专家去把握这种平衡。

期望散列表能够支持和数组大小无关的常数级别别的查找和插入操作是可能的。对于任意的符号表实现，这个期望都是理论上的最优性能。但散列表并非包含百病的灵丹妙药，因为：
- 每种类型的键都需要一个优秀的散列函数；
- 性能保证来自于散列函数的质量；
- 散列函数的计算可能复杂而且昂贵；
- 难以支持有序性相关的符号表操作；

##应用
###选择哪种符合表的实现
在这里我们将结合各种符号表算法的性能特点（散列表的最坏情况除外，它的结果来自于研究文献并且也不太可能在实际应用中遇到）。从表中显然可以知道，对于典型的应用程序，应该在散列表和二叉查找树之间进行选择。

相对二叉查找树，散列表的优点在于代码更简单，且查找时间最优（常数级别，只要键的数据类型是标准的或者简单到我们可以为它写出满足（或者近似满足）均匀性假设的高效散列函数即可）。二叉查找树相对于散列表的优点在于抽象结构更简单（不需要设计散列函数），红黑树可以保证最坏情况下的性能且它能够支持的操作更多（如排名、选择、排序和范围查找）。根据经验法则，但大多数程序员的第一选择都是散列表，在其他因素更重要时才会选择红黑树。

**各种符号表实现的渐进性能的总结**
![U3-1](https://github.com/camilesing/LearnAlgorithms/blob/9153e4aa9d168ccd92b809ac153427416ed557cd/src/main/Unit3/Images/U3-1.png?raw=true)

> 我们的符号表实现已经可以广泛应用于各种应用程序，但经过简单的修改后，这些算法还可以适应并支持其他一些使用广泛的场景，有必要在这里点一下。

####原始数据类型
假设我们有一张符号表，其中整型的键对应着浮点型的值。如果使用我们的标准实现，键和值会被存储在Integer和Double类中，因此我们需要两个额外的引用来访问每个键值对。如果应用程序只会使用几千个键进行几千次查找，那么这些引用可能没什么问题。但如果是对几十亿个键进行几十亿次查找，那么这些引用就会造成巨大的额外开销。使用原始数据类型代替Key类型可以为每个键值对节省一个引用。当键的值也是原始数据类型时我们又可以节约另外一个引用。
####重复键
符号表的实现有时需要专门考虑重复键的可能性。许多应用都希望能够为同一个键绑定多个值。例如在一个交易处理系统中，多笔交易的客户属性都是相同的。符号表不允许重复键，因此用例只能自己管理重复键。
####Java标准库
Java的`java.util.TreeMap`和`java.util.HashMap`分别是基于红黑树和拉链法的散列表的符号表实现。TreeMap没有直接支持rank()、select()和我们有序符号表API中的一些其他方法，但它支持一些高效实现这些方法的操作。HashMap也会动态调整数组的大小来保证使用率大约不超过75%。
