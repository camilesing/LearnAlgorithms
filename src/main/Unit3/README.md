#简单符号表实现的成本总结

|数据结构|算法|最坏情况下的成本（N次插入以后）的查找|最坏情况下的成本（N次插入以后）的插入|平均情况下的成本（N次随机插入后）的查找|平均情况下的成本（N次随机插入后）的插入|是否高效地支持有序性相关的操作|
|:--|:--|:--|:--|:--|:--|:--|
|无序链表|顺序查找|N|N|N/2|N|否|
|二分查找|有序数组|lgN|2N|lgN|N|是|
|二叉查找树|二叉树查找|N|N|1.39LgN|1.39LgN|是|
|红黑树|2-3树查找|2lgN|2lgN|1.001lgN|1.001lgN|是|

# 符号表的花式实现
基于之上的基础，我们可以得出一系列更复杂的符号表。比如二叉查找树，就是将二分查找的效率和链表的灵活性结合起来。

|使用的数据结构|实现|优点|缺点|
|:--|:--|:--|:--|
|链表（顺序查找）|SequentialSearchST|适用于小型问题|对于大型符号表很慢|
|有序数组（二分查找）|BinarySearchST|最优的查找效率和空间需求，能够进行有序性相关的操作|插入操作很慢|
|二叉查找树|BST|实现简单，能够进行有序性相关的操作|没有性能上界的保证，链接需要额外的空间|
|平衡二叉查找树|RedBlackBST|最优查找和插入排序，能够进行有序性相关的操作|链接需要额外的空间|
|散列表|SeparateChainHashSTLinearProbingHashST|能够快速地查找和插入常见类型的数据|需要计算每种类型的数据的散列，无法进行有序性相关的操作，链接和空结点需要额外的空间|

##散列表
散列表可以分为两种：
- 基于拉链法的散列表
- 开放地址散列表

###基于拉链法的散列表
一个散列函数能够将键转换为数组索引。散列算法的第二部是**碰撞处理**，也就是处理两个或多个键的散列值相同的情况。一种直接的办法是将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为**拉链法**，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的M（散列表大小），使得所有的链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

###开放地址散列表
其中最简单的实现是线性探测法的散列表。当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能产生三种结果：
1. 命中。该位置的键和被查找的键相同；
2. 未命中。键为空（该位置没有键）；
3. 继续查找。该位置的键和被查找的键不同；

开发第之类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。

####键簇与性能
线性探测的平均承办取决于元素在插入数组后聚集成的一组连续的条目，也叫做键簇。显然，短小的键簇才能保证较高的效率。随着插入的键越来越多，这个要求会很难满足，较长的键簇会越来越多。

#内存使用：符号表的内存使用
|方法|N个元素所需的内存（引用类型）|
|:--|:--|
|基于拉链法的散列表|~48N+32M|
|基于线性探测表的散列表|在~32N和~128N之间|
|各种二叉查找树|~56N|

拉链法和线性探测法的详细比较取决于实现的细节和用例空间和时间的要求。即使基于性能考虑，选择拉链法而非线性探测法也不一定是合理的。在实践中，两种方法的性能差别主要是因为拉链法为每个键值对都分配了一小块内存而线性探测则为整张表使用了两个很大的数组。对于非常大的散列表，这些做法对内存管理系统的要求也很不相同。在现代系统中，在性能优化的情景下，最好由专家去把握这种平衡。

期望散列表能够支持和数组大小无关的常数级别别的查找和插入操作是可能的。对于任意的符号表实现，这个期望都是理论上的最优性能。但散列表并非包含百病的灵丹妙药，因为：
- 每种类型的键都需要一个优秀的散列函数；
- 性能保证来自于散列函数的质量；
- 散列函数的计算可能复杂而且昂贵；
- 难以支持有序性相关的符号表操作；
