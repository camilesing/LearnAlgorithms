#图
##无向图
>定义：无向图是由一组顶点和一组能够将两个顶点（vertex）相连的边（edge）组成的。

特殊的图：
- 自环：即一条连接一个顶点的其自身的边
- 连接同一对顶点的两条边称为**平行边**

数学级常常将含有平行边的图称为**多重图**，而将没有平行边或自环的图称为**简单图**。
### 术语表
当两个顶点通过一条边相连时，我们称这两个顶点是**相邻的**，并称这条边**依附于**这两个顶点。某个顶点的**度数**即为依附于它的边的总数。子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够**顺序**连接这一系列的顶点的边所组成的子图。

>定义：在图中，**路径** 是由边顺序连接的一系列顶点。**简单路径** 是一条没有重复顶点的路径。**环** 是一条至少含有一条边且起点和终点相同的路径。**简单环** 是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的 **长度** 为其中所包含的边数。

>定义：如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是**连通图**。一副非连通的图是由若干连通的部分组成，它们都是其极大连通子图。

>定义：树是一副无环连通图。互不相连的树组成的集合称为**森林**。连通图的**生成树**是它的一副子图，它含有图中的所有顶点且是一棵树。图的**生成树森林**是它所有连通子图的生成树的集合。

###图的表示方法
####邻接矩阵
我们可以使用一个V乘V的布尔矩阵。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素至为true，否则为false。这种表示方法不符合第一个条件——含有上百个个顶点的图是很常见的，V^2个布尔值锁需要的空间是不能被满足的。

####边的数组
我们可以使用一个Edge类，它含有两个int实例标量。这种表示方法很简洁但不满足第二个条件——要实现adj()需要检查图中的所有边。
####邻接表数组
我们可以使用一个顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。这是一个不错的实现。

**典型Graph实现的性能复杂度**
|数据结构|所需空间|添加一条边v-w|检查w和v是否相邻|遍历v的所有相邻顶点|
|:--|:--|:--|:--|:--|
|边的列表|E|1|E|E|
|邻接矩阵|V^2|1|1|V|
|邻接表|E+V|1|degree(v)|degree(v)|
|邻接表|E+V|logV|logV|logV+degree(v)|

##图处理算法的API
**public class Search**
|返回类型|方法名|简介|
|:--|:--|:--|
||Search(Graph g,int s)|找到和起点s连通的所有点|
|boolean|marked(int v)|v和s是连通的吗|
|int |count()|与s连通的顶点总数|

###深度优先算法
主要思想：
- 用一个递归的方法来遍历所有顶点
- 将它标记为已访问
- 递归地访问它的所有没有被标记的邻居顶点


>深度优先搜索标记与起点连通的所欲哦顶点所需的时间和顶点的读书之和成正比。

## 寻找路径
**public class Search**
|返回类型|方法名|简介|
|:--|:--|:--|
||Paths(Graph g,int s)|从G中找出所有起点为s的路径|
|boolean|hasPathTo(int v)|是否存在从s到v的路径|
|Iterable<Integer>|pathTo()|s到v的路径，如果不存在则返回null|

### 广度优先搜索
深度优先搜索得到的路径不仅是取决于图的结构，还取决于图的表示和递归调用的兴致。我们很自然地还经常对下面这些问题感兴趣。

>单点最短路径。给定一幅图和一个起点s，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。等类似问题”

解决这个问题的经典方法叫做**广度优先搜索（BFS）** 。因为深度优先搜索在这个问题上没有什么作为，因为它遍历整个图的顺序和找出最短路径的目标没有任何关系。

在深度优先搜索中，我们用了一个可以下压的栈（由系统管理，以支持递归搜索方法）。使用LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，我们希望按照起点的举例的顺序来遍历所有顶点，看起来这种顺序很容易实现：使用（FIFO，先进先出）队列来替代栈（LIFO，先进后出）即可。我们将从有待搜索的通道中选择最早遇到的那条。

####实现
`BreadthFirstPaths`实现了广度优先搜索算法。它使用了一个队列来保存所有已经被标记但其领表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤知道队列为空：
1. 取队列中的下一个顶点v并标记它
2. 将与v相邻的所有未被标记过的顶点加入队列

在这里，bfs()方法不是递归的。不像递归中隐式使用的栈，它显示地使用了一个队列。

对于从s可大的任意顶点v，广度优先搜索都能找到一条从s到v的最短路径（没有其他从s到v的路径所含的边比这条路径更少）。另外，广度优先搜索所需的时间在最坏情况下和V+E成正比。

###小结
深度优先搜索和广度优先搜索是几种常用并且通用的图搜索的算法。在搜索中我们都会将起点存入数据结构中，然后重复以下步骤直到数据结构被清空：
1. 取其中的下一个顶点并标记它
2. 将v的所有相邻而又未被标记的顶点加入数据结构

###连通分量
深度优先搜索的下一个直接应用就是找出一幅图的所有连通分量。

**CC类的API**
|返回类型|方法名|简介|
|:--|:--|:--|
||CC(Graph G)|预处理构造函数|
|boolean|connected(int v, int w)|v和w连通吗|
|int|count()|连通分量数|
|int|id(int v)|v所在的连通分量的标识符(0~count()-1)|

###符号图
在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来表示和指代顶点。为了适应这样的应用，我们定义了拥有以下性质的输入格式：
- 顶点名为字符串
- 用指定的分隔符来隔开顶点名（允许顶点名中含有空格）
- 每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点
- 顶点总数V和边的总数E都是隐式定义的

**SymbolGraph类的API**
|返回类型|方法名|简介|
|:--|:--|:--|
||SymbolGraph(String filename,String delim)|根据filename指定的文件构造图，使用delim来分隔顶点名|
|boolean|contains(String key)|key是一个顶点吗|
|int|index(String key)|Key的索引|
|String|name(int v)|索引v的顶点名|
|Graph|G()|隐藏的Graph对象|

####实现
SymbolGraph的用到了下面3种数据结构：
- 一个符号表st，键的类型为String(顶点名)，值的类型为int（索引）
- 一个数组Keys[]，用作反向索引，保存每个顶点索引所对应的顶点名
- 一个Graph对象G，它使用索引来引用图中顶点
